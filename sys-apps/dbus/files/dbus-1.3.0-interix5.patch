diff -ru dbus-1.3.0.orig/dbus/dbus-server-unix.c dbus-1.3.0/dbus/dbus-server-unix.c
--- dbus-1.3.0.orig/dbus/dbus-server-unix.c	2010-02-02 15:10:03 +0100
+++ dbus-1.3.0/dbus/dbus-server-unix.c	2010-02-02 15:12:54 +0100
@@ -100,9 +100,16 @@
               return DBUS_SERVER_LISTEN_DID_NOT_CONNECT;
             }
               
+#if defined(__INTERIX)
+		  // need to take good care that this doesn't get too long!!
+          if (!_dbus_string_append (&filename,
+                                    "ds") ||
+              !_dbus_generate_random_ascii (&filename, 6) ||
+#else
           if (!_dbus_string_append (&filename,
                                     "dbus-") ||
               !_dbus_generate_random_ascii (&filename, 10) ||
+#endif
               !_dbus_string_append (&full_path, tmpdir) ||
               !_dbus_concat_dir_and_file (&full_path, &filename))
             {
diff -ru dbus-1.3.0.orig/dbus/dbus-sysdeps-unix.c dbus-1.3.0/dbus/dbus-sysdeps-unix.c
--- dbus-1.3.0.orig/dbus/dbus-sysdeps-unix.c	2010-02-02 15:10:03 +0100
+++ dbus-1.3.0/dbus/dbus-sysdeps-unix.c	2010-02-02 15:13:26 +0100
@@ -55,6 +55,10 @@
 #include <netdb.h>
 #include <grp.h>
 
+#if defined(__INTERIX)
+# include <arpa/inet.h>
+#endif
+
 #ifdef HAVE_ERRNO_H
 #include <errno.h>
 #endif
@@ -1084,8 +1088,10 @@
 {
   int saved_errno = 0;
   int fd = -1, res;
+#ifndef __INTERIX
   struct addrinfo hints;
   struct addrinfo *ai, *tmp;
+#endif
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
@@ -1097,6 +1103,7 @@
 
   _DBUS_ASSERT_ERROR_IS_CLEAR(error);
 
+#ifndef __INTERIX
   _DBUS_ZERO (hints);
 
   if (!family)
@@ -1149,6 +1156,60 @@
       break;
     }
   freeaddrinfo(ai);
+#else
+  {
+      char **cur;
+      struct hostent* h;
+      int fam = AF_UNSPEC;
+
+      if((h = gethostbyname(host)) == NULL)
+      {
+        dbus_set_error(error, _dbus_error_from_errno (errno),
+               "Failed to get host information for \"%s\"", host);
+        return -1;
+      }
+
+      if(family) {
+        if(strcmp(family, "ipv4") == 0)
+          fam = AF_INET;
+        else
+        {
+          dbus_set_error (error,
+                          _dbus_error_from_errno (errno),
+                          "Unknown address family %s", family);
+          return -1;
+        }
+      }
+
+      cur = h->h_addr_list;
+
+      while(*cur)
+      {
+          struct sockaddr_in s;
+
+          s.sin_family = fam;
+          s.sin_port = htons(atoi(port));
+          inet_aton(*cur, &s.sin_addr);
+
+          if (!_dbus_open_socket (&fd, fam, SOCK_STREAM, 0, error))
+          {
+            _DBUS_ASSERT_ERROR_IS_SET(error);
+            return -1;
+          }
+          _DBUS_ASSERT_ERROR_IS_CLEAR(error);
+
+          if (connect (fd, (struct sockaddr*)&s, sizeof(s)) < 0)
+          {
+            _dbus_close(fd, NULL);
+            fd = -1;
+
+            ++cur;
+            continue;
+          }
+          break;
+      }
+  }
+#endif
 
   if (fd == -1)
     {
@@ -1197,12 +1258,15 @@
 {
   int saved_errno;
   int nlisten_fd = 0, *listen_fd = NULL, res, i;
+#ifndef __INTERIX
   struct addrinfo hints;
   struct addrinfo *ai, *tmp;
+#endif
 
   *fds_p = NULL;
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
+#ifndef __INTERIX
   _DBUS_ZERO (hints);
 
   if (!family)
@@ -1335,6 +1399,92 @@
     }
   freeaddrinfo(ai);
   ai = NULL;
+#else
+  {
+    char **cur;
+    struct hostent* h;
+    int fam = AF_UNSPEC;
+
+    if((h = gethostbyname(host)) == NULL)
+    {
+      dbus_set_error(error, _dbus_error_from_errno (errno),
+             "Failed to get host information for \"%s\"", host);
+      return -1;
+    }
+
+    if(family) {
+      if(strcmp(family, "ipv4") == 0)
+        fam = AF_INET;
+      else
+      {
+        dbus_set_error (error,
+                        _dbus_error_from_errno (errno),
+                        "Unknown address family %s", family);
+        return -1;
+      }
+    }
+
+    cur = h->h_addr_list;
+
+    while(*cur)
+    {
+      int fd = -1, *newlisten_fd;
+      struct sockaddr_in s;
+
+      s.sin_family = fam;
+      s.sin_port = htons(atoi(port));
+      inet_aton(*cur, &s.sin_addr);
+
+      if (!_dbus_open_socket (&fd, fam, SOCK_STREAM, 0, error))
+        {
+          _DBUS_ASSERT_ERROR_IS_SET(error);
+          goto failed;
+        }
+      _DBUS_ASSERT_ERROR_IS_CLEAR(error);
+
+      if (bind (fd, (struct sockaddr*)&s, sizeof(s)) < 0)
+        {
+          _dbus_close(fd, NULL);
+          if (errno == EADDRINUSE)
+            {
+              /* Depending on kernel policy, it may or may not
+                 be neccessary to bind to both IPv4 & 6 addresses
+                 so ignore EADDRINUSE here */
+              ++cur;
+              continue;
+            }
+          dbus_set_error (error, _dbus_error_from_errno (errno),
+                          "Failed to bind socket \"%s:%s\": %s",
+                          host ? host : "*", port, _dbus_strerror (errno));
+          goto failed;
+        }
+
+      if (listen (fd, 30 /* backlog */) < 0)
+        {
+          _dbus_close (fd, NULL);
+          dbus_set_error (error, _dbus_error_from_errno (errno),
+                          "Failed to listen on socket \"%s:%s\": %s",
+                          host ? host : "*", port, _dbus_strerror (errno));
+          goto failed;
+        }
+
+      newlisten_fd = dbus_realloc(listen_fd, sizeof(int)*(nlisten_fd+1));
+      if (!newlisten_fd)
+        {
+          _dbus_close (fd, NULL);
+          dbus_set_error (error, _dbus_error_from_errno (errno),
+                          "Failed to allocate file handle array: %s",
+                          _dbus_strerror (errno));
+          goto failed;
+        }
+      listen_fd = newlisten_fd;
+      listen_fd[nlisten_fd] = fd;
+      nlisten_fd++;
+
+      ++cur;
+    }
+  }
+#endif
 
   if (!nlisten_fd)
     {
@@ -1358,8 +1508,10 @@
   return nlisten_fd;
 
  failed:
+#ifndef __INTERIX
   if (ai)
     freeaddrinfo(ai);
+#endif
   for (i = 0 ; i < nlisten_fd ; i++)
     _dbus_close(listen_fd[i], NULL);
   dbus_free(listen_fd);
