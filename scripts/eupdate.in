#!/usr/bin/env bash

# <grobian@gentoo.org> -- 2006-11-03
# let eapify figure out what should be done to a file.  This requires
# the extension of the file to be retained in the temp location, but
# afterwards it works nicely for eclasses and ebuilds, as well as
# ChangeLogs.
# <grobian@gentoo.org> -- 2006-09-22
# eupdate: a not yet fully complete bucket of voodoo to sync a the
# prefix tree with the mainline tree.  Strategies followed are largerly
# based on cvs revision numbers and diffs between those revisions.  For
# the real internals, please look at the comments below in the code.  In
# general, this script checks if an ebuild contains the most recent
# changes to it, and if there is a newer ebuild available.  In both
# cases (cross) diffing techniques are used to maintain the manually
# made changes.
#
# This script doesn't run out of the box, you have to feed it some paths
# so it can do it's magic stuff.  Also, you have to be a gentoo
# developer with cvs access.  (Or when anoncvs is available, every user
# can do it.)  For your convenience it is intended that you rename this
# file to something without the .in and change the paths below.

# Main Tree Directory, an rsynced portage tree is fine
MTREEDIR='/usr/portage'
# Prefix offset
EPREFIX='/my/prefix'
# Prefix Tree Directory
PTREEDIR="`cd ${EPREFIX}/usr/portage && pwd -P`"
# How to reach the CVS server for retrieving revision diffs
CVSROOT=':ext:developer@cvs.gentoo.org:/var/cvsroot/'
# Don't touch this.  You really don't want to.
CVSMODULE='gentoo-x86'
# Voodoo to figure out what package you're currently messing with
EPACKAGE="`pwd -P`"; EPACKAGE=${EPACKAGE#*${PTREEDIR}/}

[[ -e "${EPREFIX}"/etc/init.d/functions.sh ]] \
	&& source "${EPREFIX}"/etc/init.d/functions.sh \
	|| echo "!!! cannot find functions.sh !!!"

[[ -z $DO_INDENT ]] || RC_INDENTATION=$DO_INDENT

# returns the CVS revision number from the $Header
get_cvsversion() {
	if [[ -z $1 ]] ; then
		echo 0
		return
	fi

	ver=`egrep '(^|[^\\])\\\$Header:' "$1" | egrep -m1 -o "v [0-9.]+" | head -n1`
	if [[ $ver == "" ]] ; then
		echo 0
		return
	fi
	echo ${ver#v }
}

# Comparator for ebuild version strings.  Returns 0 if both arguments
# are equal, a number less then 0 if the first argument is smaller than
# the second, and a number greater then 0 otherwise.  Arguments may be
# up to full paths to the bare version string only.
# It is possible to deduce what the largest difference between the two
# given versions is, by considering the following on the absolute return
# value: 10000 < x < 0 -> main version, where 1 is a difference in
# the major, 10 a difference in the minor, etc. 100000 < x < 10000 ->
# suffix, 1000000 < x < 100000 -> revision.
cmp_ebuild_ver() {
	# get the bare version, if not already
	local l=$(get_ebuildversion $1)
	local r=$(get_ebuildversion $2)

	if [[ -z $l ]] ; then
		echo 0
		return
	elif [[ -z $r ]] ; then
		echo 1
		return
	fi

	local lver=`echo $l | cut -d'-' -f1`
	local lrev=`echo ${l#$lver} | cut -d'-' -f2`
	local t=$lver
	lver=`echo $t | cut -d'_' -f1`
	local lsuf=`echo ${t#$lver} | cut -d'_' -f2`

	local rver=`echo $r | cut -d'-' -f1`
	local rrev=`echo ${r#$rver} | cut -d'-' -f2`
	t=$rver
	rver=`echo $t | cut -d'_' -f1`
	local rsuf=`echo ${t#$rver} | cut -d'_' -f2`

	local cnt=1
	# start "eating" the version from the left, comparing the numbers,
	# following an exit-early approach
	while [[ $lver != "" ]] || [[ $rver != "" ]] ; do
		# get the "head" component
		local la=${lver%%.*}
		local ra=${rver%%.*}
		# unfortunately also characters next to numbers can appear in
		# the version number, 4a is considered to be smaller than 33
		local lan=${la%%[a-zA-Z]*}
		local ran=${ra%%[a-zA-Z]*}
		t=$((lan - ran))
		if [[ ${t} != 0 ]] ; then
			[[ $t > 9 ]] && t=9
			[[ $t < -9 ]] && t=-9
			echo $((t * cnt))
			return
		else
			# perform string equality... should work
			if [[ ${la} < ${ra} ]] ; then
				echo $((-1 * cnt))
				return
			elif [[ ${la} > ${ra} ]] ; then
				echo $cnt
				return
			fi
		fi

		# remove the part we processed (and was equal)
		lver=${lver#${la}}
		rver=${rver#${ra}}
		# strip leading dot (if any)
		lver=${lver#.}
		rver=${rver#.}

		[[ $cnt < 1000 ]] && cnt=$((cnt * 10))
	done

	# the main version components are equal, dive into the suffices

	# suffix precedence rules:
	# alpha
	# beta
	# pre
	# rc
	# (none)
	# p

	cnt=10000
	local lan=0
	case $lsuf in
		alpha*)
			lan=-1
			lsuf=${lsuf#alpha}
		;;
		beta*)
			lan=-2
			lsuf=${lsuf#beta}
		;;
		pre*)
			lan=-3
			lsuf=${lsuf#pre}
		;;
		rc*)
			lan=-4
			lsuf=${lsuf#rc}
		;;
		p*)
			lan=-6
			lsuf=${lsuf#p}
		;;
		*)
			lan=-5
		;;
	esac

	local ran=0
	case $rsuf in
		alpha*)
			ran=-1
			rsuf=${rsuf#alpha}
		;;
		beta*)
			ran=-2
			rsuf=${rsuf#beta}
		;;
		pre*)
			ran=-3
			rsuf=${rsuf#pre}
		;;
		rc*)
			ran=-4
			rsuf=${rsuf#rc}
		;;
		p*)
			ran=-6
			rsuf=${rsuf#p}
		;;
		*)
			ran=-5
		;;
	esac

	t=$((lan - ran))
	if [[ ${t} != 0 ]] ; then
		echo $((t * cnt))
		return
	fi
	t=$((lsuf - rsuf))
	if [[ ${t} != 0 ]] ; then
		[[ $t > 9 ]] && t=9
		[[ $t < -9 ]] && t=-9
		echo $((t * cnt))
		return
	fi

	# suffices were equal too, now lets see the revision

	cnt=100000
	lrev=${lrev#r}
	rrev=${rrev#r}
	
	t=$((lrev - rrev))
	[[ $t > 9 ]] && t=9
	[[ $t < -9 ]] && t=-9
	echo $((t * cnt))
}

get_ebuildversion() {
	if [[ -z $1 ]] ; then
		return
	fi

	# strip extention
	t=${1%.ebuild}
	# abort if this is not an ebuild
	if [[ $t == $1 ]] ; then
		return
	fi
	# strip package name
	t=${t#*-}
	# sometimes there are dashes in the package name
	while [[ ${t:0:1} < "0" || ${t:0:1} > "9" ]] ; do
		[[ $t != ${t#*-} ]] \
			&& t=${t#*-} \
			|| break
	done

	echo ${t}
}

cross_diff() {
	mver=$(get_ebuildversion $1)
	pver=$(get_ebuildversion $2)
	mte=`basename "${MTREEDIR}/${EPACKAGE}"/$1`
	pte=`echo $2`
	mtecv=$(get_cvsversion "${MTREEDIR}/${EPACKAGE}"/$mte)
	ptecv=$(get_cvsversion $pte)
	ewarn "new version in main tree: ${mver} [${pver}] ... cross diff from $ptecv to $mtecv"
	# checkout both original versions and make the diffs,
	# ignoring keywords
	tmp="tmp.${package##*.}"
	cvs -Q -d"${CVSROOT}" \
		checkout -r$ptecv -p ${CVSMODULE}/${EPACKAGE}/$pte \
		> /var/tmp/$pte-$ptecv.$tmp
	cvs -Q -d"${CVSROOT}" \
		checkout -r$mtecv -p ${CVSMODULE}/${EPACKAGE}/$mte \
		> /var/tmp/$mte-$mtecv.$tmp
	# create the new file to patch against
	cp $pte $mte
	# Sanitise the $Header line, because it may differ being in the
	# Attic or something.  Use version of main tree, to keep updates
	# working.
	sed -i \
		-e 's|^# \$Header:.*$|'"`egrep '^# \\\$Header: ' /var/tmp/$mte-$mtecv.$tmp`"'|' \
		$mte /var/tmp/$pte-$ptecv.$tmp
	# make KEYWORDS void in the diff
	sed -i \
		-e 's|^KEYWORDS=.*$|'"`egrep '^KEYWORDS=' $pte`"'|' \
		/var/tmp/$pte-$ptecv.$tmp /var/tmp/$mte-$mtecv.$tmp
	# destroy changes (hopefully) with the prefixed version by eapifying
	eapify /var/tmp/$pte-$ptecv.$tmp /var/tmp/$mte-$mtecv.$tmp > /dev/null
	# (attempt to) do it!
	diff -u /var/tmp/$pte-$ptecv.$tmp /var/tmp/$mte-$mtecv.$tmp \
		| patch --no-backup-if-mismatch $mte
	rm /var/tmp/$pte-$ptecv.$tmp /var/tmp/$mte-$mtecv.$tmp
}

revision_diff() {
	mtecv=$1
	ptecv=$2
	package=$3
	# Gentoo never increments the major, and branches are not
	# allowed, so we can make things easy and only use the minor
	if [[ ${mtecv#1.} -eq ${ptecv#1.} ]] ; then
		return
	elif [[ ${mtecv#1.} -gt ${ptecv#1.} ]] ; then
		echo "out-of-date, applying diff -r$ptecv -r$mtecv"
		# checkout both original versions and make the diffs,
		# ignoring keywords
		tmp="tmp.${package##*.}"
		cvs -Q -d"${CVSROOT}" \
			checkout -r$ptecv -p ${CVSMODULE}/${EPACKAGE}/$package \
			> /var/tmp/$package-$ptecv.$tmp
		cvs -Q -d"${CVSROOT}" \
			checkout -r$mtecv -p ${CVSMODULE}/${EPACKAGE}/$package \
			> /var/tmp/$package-$mtecv.$tmp
		# make KEYWORDS void in the diff
		[[ ${package##*.} == "ebuild" ]] && sed -i \
			-e 's|^KEYWORDS=.*$|'"`egrep '^KEYWORDS=' $package`"'|' \
			/var/tmp/$package-$ptecv.$tmp /var/tmp/$package-$mtecv.$tmp
		# destroy changes (hopefully) with the prefixed version by eapifying
		eapify /var/tmp/$package-$ptecv.$tmp /var/tmp/$package-$mtecv.$tmp > /dev/null
		# show what's going to change
		diff -U 1 /var/tmp/$package-$ptecv.$tmp /var/tmp/$package-$mtecv.$tmp
		# (attempt to) do it!
		diff -u /var/tmp/$package-$ptecv.$tmp /var/tmp/$package-$mtecv.$tmp \
			| patch --no-backup-if-mismatch $package
		ret=$?
		rm /var/tmp/$package-$ptecv.$tmp /var/tmp/$package-$mtecv.$tmp
		return $ret
	fi
}

diff_patch() {
	diff -u $1 "${MTREEDIR}/${EPACKAGE}"/$1 | patch $1
	return $?
}

update_file() {
	# on directories, recurse
	if [[ -d $1 ]] ; then
		eindent
		# recurse into this directory (don't update digests)
		( cd $1 && DO_INDENT=$RC_INDENTATION eupdate $(ls -p | egrep -v "^digest-") )
		eoutdent
		return
	fi

	# check existence of files
	if [[ ! -f $1 ]] ; then
		echo "no such file: $1"
		return -1
	fi
	if [[ ! -f "${MTREEDIR}/${EPACKAGE}"/$1 ]] ; then
		echo "$1 not found in the main tree"
		return -1
	fi

	# see if the file has a CVS header
	mtecv=$(get_cvsversion "${MTREEDIR}/${EPACKAGE}"/$1)
	ptecv=$(get_cvsversion $1)
	if [[ $mtecv == 0 ]] && [[ $ptecv == 0 ]] ; then
		diff_patch $1
		return $?
	else
		revision_diff $mtecv $ptecv $1
		return $?
	fi
}

do_check_file() {
	file=$1
	msg=$2
	[[ -z $2 ]] && msg="checking $file"

	if [[ -d $1 ]] ; then
		einfo "$msg (a directory)"
		update_file $file
		return
	fi

	ebegin $msg
	err=$(update_file $file)
	ret=$?
	eend $ret
	if [[ ! -z $err ]] ; then
		[[ $ret != 0 ]] \
			&& eerror "$file: $err" \
			|| einfo "$file: $err"
	fi
}

# if the user gave some files on the command line, try to update those
if [[ ${#*} > 0 ]] ; then
	while [[ ${#*} > 0 ]] ; do
		do_check_file $1
		shift
	done

	# we're done
	exit 0
fi

if [[ ! -d ${MTREEDIR}/${EPACKAGE} ]] ; then
	eerror "no such package in main tree: ${EPACKAGE}"
	exit -1
fi

if [[ ${EPACKAGE} == "eclass" ]] ; then
	einfo "Processing eclasses directory"
	mt=`cd "${MTREEDIR}"/${EPACKAGE}/ && ls -p`
	pt=`ls -p`
	# nested loop join
	for pte in $pt ; do
		had_match=0
		for mte in $mt ; do
			if [[ $pte == $mte ]] ; then
				do_check_file $mte "found $mte in both"
				had_match=1;
				# we don't need $pte/$mte any more
				pt=${pt/$pte/}
				mt=${mt/$mte/}
				break;
			fi
		done
		[[ $had_match == 0 ]] \
			&& echo "  warning: $pte no longer in the main tree"
	done

	# everything left in $mt now is what's not in $pt, let's make a
	# note about them
	for mte in $mt ; do
		echo "  only in main tree: $mte"
	done
	echo "done"
	exit 0
fi

einfo "Processing ${EPACKAGE}"
mt=`cd "${MTREEDIR}"/${EPACKAGE}/ && ls -p | egrep -v "^Manifest$"`
pt=`ls -p | egrep -v "^Manifest$"`
# do a nested loop join, we don't assume any order
for pte in $pt ; do
	had_match=0
	last_rev=0
	for mte in $mt ; do
		# calculate the diffs between prefix and main
		vdiff=$(cmp_ebuild_ver $mte $pte)
		# if we have the same ebuild version... (or file)
		if [[ $vdiff == 0 ]] && [[ $mte == $pte ]] ; then
			had_match=1
			# ... look inside the files to see if the file was updated or not
			do_check_file $mte "found $mte in both"
			# we found this version, so needless to look for it any more
			mt=${mt/$mte/}
		elif [[ $vdiff -ge 100000 ]] ; then
			# we have an updated revision: track it
			[[ $(cmp_ebuild_ver $last_rev $mte) < 0 ]] \
				&& last_rev=$mte
			# we don't need to look at revisions lateron because we
			# update them here
			mt=${mt/$mte/}
		fi
	done
	# stale entry
	[[ $had_match == 0 ]] \
		&& ewarn "warning: $pte no longer in the main tree"
	# revision update
	[[ $last_rev != 0 ]] \
		&& cross_diff $last_rev $pte
done
# what's left in $mt is everything which is not in $pt
last_pte=""
for pte in $pt ; do
	[[ $(cmp_ebuild_ver $pte $last_pte) > 0 ]] \
		&& last_pte=$pte
done
# if there is anything left in mt that is bigger than last_pte we want
# the biggest of that
last_mte=""
for mte in $mt ; do
	[[ $(cmp_ebuild_ver $mte $last_pte) > 0 ]] && \
	[[ $(cmp_ebuild_ver $mte $last_mte) > 0 ]] \
		&& last_mte=$mte
done
if [[ $last_mte != "" ]] ; then
	# we have to apply an update from $last_pte to $last_match
	cross_diff $last_mte $last_pte
fi
