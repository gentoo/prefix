http://thread.gmane.org/gmane.comp.security.oss.general/1847
http://bugs.gentoo.org/show_bug.cgi?id=274488

whitespace-only hunks removed

Index: init.h
===================================================================
--- init.h (revision 5639:e3af935cdb1a)
+++ init.h (revision 5665:b6b37a6a7f72)
@@ -2145,4 +2145,20 @@
   ** advertising the capability. When \fIunset\fP, mutt will not attempt to
   ** use \fCSTARTTLS\fP regardless of the server's capabilities.
+  */
+  { "ssl_verify_dates", DT_BOOL, R_NONE, OPTSSLVERIFYDATES, M_YES },
+  /*
+  ** .pp
+  ** If \fIset\fP (the default), mutt will not automatically accept a server
+  ** certificate that is either not yet valid or already expired. You should
+  ** only unset this for particular known hosts, using the
+  ** \fC$<account-hook>\fP function.
+  */
+  { "ssl_verify_host", DT_BOOL, R_NONE, OPTSSLVERIFYHOST, M_YES },
+  /*
+  ** .pp
+  ** If \fIset\fP (the default), mutt will not automatically accept a server 
+  ** certificate whose host name does not match the host used in your folder
+  ** URL. You should only unset this for particular known hosts, using
+  ** the \fC$<account-hook>\fP function.
   */
   { "certificate_file",	DT_PATH, R_NONE, UL &SslCertFile, UL "~/.mutt_certificates" },
Index: mutt.h
===================================================================
--- mutt.h (revision 5535:2050b44407bf)
+++ mutt.h (revision 5665:b6b37a6a7f72)
@@ -371,4 +371,6 @@
   OPTTLSV1,
   OPTSSLFORCETLS,
+  OPTSSLVERIFYDATES,
+  OPTSSLVERIFYHOST,
 #endif /* defined(USE_SSL) */
   OPTIMPLICITAUTOVIEW,
Index: mutt_ssl.c
===================================================================
--- mutt_ssl.c (revision 5622:3af7e8af1983)
+++ mutt_ssl.c (revision 5870:dc9ec900c657)
@@ -565,17 +565,20 @@
 
   /* expiration check */
-  if (X509_cmp_current_time (X509_get_notBefore (peercert)) >= 0)
-  {
-    dprint (2, (debugfile, "Server certificate is not yet valid\n"));
-    mutt_error (_("Server certificate is not yet valid"));
-    mutt_sleep (2);
-    return 0;
-  }
-  if (X509_cmp_current_time (X509_get_notAfter (peercert)) <= 0)
-  {
-    dprint (2, (debugfile, "Server certificate has expired"));
-    mutt_error (_("Server certificate has expired"));
-    mutt_sleep (2);
-    return 0;
+  if (option (OPTSSLVERIFYDATES) != M_NO)
+  {
+    if (X509_cmp_current_time (X509_get_notBefore (peercert)) >= 0)
+    {
+      dprint (2, (debugfile, "Server certificate is not yet valid\n"));
+      mutt_error (_("Server certificate is not yet valid"));
+      mutt_sleep (2);
+      return 0;
+    }
+    if (X509_cmp_current_time (X509_get_notAfter (peercert)) <= 0)
+    {
+      dprint (2, (debugfile, "Server certificate has expired"));
+      mutt_error (_("Server certificate has expired"));
+      mutt_sleep (2);
+      return 0;
+    }
   }
 
@@ -585,5 +588,5 @@
   if (!X509_digest (peercert, EVP_sha1(), peermd, &peermdlen))
   {
-    fclose (fp);
+    safe_fclose (&fp);
     return 0;
   }
@@ -592,10 +595,10 @@
   {
     pass = compare_certificates (cert, peercert, peermd, peermdlen) ? 0 : 1;
-    
+
     if (pass)
       break;
   }
   X509_free (cert);
-  fclose (fp);
+  safe_fclose (&fp);
 
   return pass;
@@ -737,6 +740,8 @@
 }
 
-/* check whether cert is preauthorized */
-static int ssl_check_preauth (X509 *cert, CONNECTION *conn)
+/* check whether cert is preauthorized. If host is not null, verify that
+ * it matches the certificate.
+ * Return > 0: authorized, < 0: problems, 0: unknown validity */
+static int ssl_check_preauth (X509 *cert, const char* host)
 {
   char buf[SHORT_STRING];
@@ -750,11 +755,14 @@
 
   buf[0] = 0;
-  if (!check_host (cert, conn->account.host, buf, sizeof (buf)))
-  {
-    mutt_error (_("Certificate host check failed: %s"), buf);
-    mutt_sleep (2);
-    return -1;
-  }
-  dprint (2, (debugfile, "ssl_check_preauth: hostname check passed\n"));
+  if (host && option (OPTSSLVERIFYHOST) != M_NO)
+  {
+    if (!check_host (cert, host, buf, sizeof (buf)))
+    {
+      mutt_error (_("Certificate host check failed: %s"), buf);
+      mutt_sleep (2);
+      return -1;
+    }
+    dprint (2, (debugfile, "ssl_check_preauth: hostname check passed\n"));
+  }
 
   if (check_certificate_by_signer (cert))
@@ -780,42 +788,28 @@
   X509 *cert;
 
-  if ((preauthrc = ssl_check_preauth (data->cert, conn)) > 0)
+  if ((preauthrc = ssl_check_preauth (data->cert, conn->account.host)) > 0)
     return preauthrc;
 
   chain = SSL_get_peer_cert_chain (data->ssl);
   chain_len = sk_X509_num (chain);
-  if (!chain || (chain_len < 1))
+  /* negative preauthrc means the certificate won't be accepted without
+   * manual override. */
+  if (preauthrc < 0 || !chain || (chain_len <= 1))
     return interactive_check_cert (data->cert, 0, 0);
 
-  /* check the chain from root to peer */
+  /* check the chain from root to peer. */
   for (i = chain_len-1; i >= 0; i--)
   {
     cert = sk_X509_value (chain, i);
-    if (check_certificate_cache (cert))
-      dprint (2, (debugfile, "ssl chain: already cached: %s\n", cert->name));
-    else if (i /* 0 is the peer */ || !preauthrc)
-    {
-      if (check_certificate_by_signer (cert))
-      {
-	dprint (2, (debugfile, "ssl chain: checked by signer: %s\n", cert->name));
-	ssl_cache_trusted_cert (cert);
+
+    /* if the certificate validates or is manually accepted, then add it to
+     * the trusted set and recheck the peer certificate */
+    if (ssl_check_preauth (cert, NULL)
+	|| interactive_check_cert (cert, i, chain_len))
+    {
+      ssl_cache_trusted_cert (cert);
+      if (ssl_check_preauth (data->cert, conn->account.host))
 	return 1;
-      }
-      else if (SslCertFile && check_certificate_by_digest (cert))
-      {
-	dprint (2, (debugfile, "ssl chain: trusted with file: %s\n", cert->name));
-	ssl_cache_trusted_cert (cert);
-	return 1;
-      }
-      else /* allow users to shoot their foot */
-      {
-	dprint (2, (debugfile, "ssl chain: check failed: %s\n", cert->name));
-	if (interactive_check_cert (cert, i, chain_len))
-	  return 1;
-      }
-    }
-    else /* highly suspicious because (i==0 && preauthrc < 0) */
-      if (interactive_check_cert (cert, i, chain_len))
-	return 1;
+    }
   }
 
@@ -882,6 +876,8 @@
 	    len - idx, len);
   menu->title = title;
-  if (SslCertFile && X509_cmp_current_time (X509_get_notAfter (cert)) >= 0
-      && X509_cmp_current_time (X509_get_notBefore (cert)) < 0)
+  if (SslCertFile
+      && (option (OPTSSLVERIFYDATES) == M_NO
+	  || (X509_cmp_current_time (X509_get_notAfter (cert)) >= 0
+	      && X509_cmp_current_time (X509_get_notBefore (cert)) < 0)))
   {
     menu->prompt = _("(r)eject, accept (o)nce, (a)ccept always");
@@ -893,5 +889,5 @@
     menu->keys = _("ro");
   }
-  
+
   helpstr[0] = '\0';
   mutt_make_help (buf, sizeof (buf), _("Exit  "), MENU_GENERIC, OP_EXIT);
@@ -918,5 +914,5 @@
 	  if (PEM_write_X509 (fp, cert))
 	    done = 1;
-	  fclose (fp);
+	  safe_fclose (&fp);
 	}
 	if (!done)
