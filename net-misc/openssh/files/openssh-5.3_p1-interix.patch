diff -ruN openssh-5.3p1.orig/auth-pam.c openssh-5.3p1/auth-pam.c
--- openssh-5.3p1.orig/auth-pam.c	2009-10-07 17:18:13 +0200
+++ openssh-5.3p1/auth-pam.c	2009-10-07 17:19:32 +0200
@@ -265,7 +265,7 @@
 	if (setreuid(sshpam_authctxt->pw->pw_uid, -1) == -1)
 		fatal("%s: setreuid failed: %s", __func__, strerror(errno));
 	result = pam_chauthtok(pamh, flags);
-	if (setreuid(0, -1) == -1)
+	if (setreuid(ROOT_UID, -1) == -1)
 		fatal("%s: setreuid failed: %s", __func__, strerror(errno));
 	return result;
 }
@@ -781,7 +781,7 @@
 			}
 			if (type == PAM_SUCCESS) {
 				if (!sshpam_authctxt->valid ||
-				    (sshpam_authctxt->pw->pw_uid == 0 &&
+				    (sshpam_authctxt->pw->pw_uid == ROOT_UID &&
 				    options.permit_root_login != PERMIT_YES))
 					fatal("Internal error: PAM auth "
 					    "succeeded when it should have "
@@ -832,7 +832,7 @@
 	}
 	buffer_init(&buffer);
 	if (sshpam_authctxt->valid &&
-	    (sshpam_authctxt->pw->pw_uid != 0 ||
+	    (sshpam_authctxt->pw->pw_uid != ROOT_UID ||
 	    options.permit_root_login == PERMIT_YES))
 		buffer_put_cstring(&buffer, *resp);
 	else
@@ -1195,7 +1195,7 @@
 	 * by PermitRootLogin, use an invalid password to prevent leaking
 	 * information via timing (eg if the PAM config has a delay on fail).
 	 */
-	if (!authctxt->valid || (authctxt->pw->pw_uid == 0 &&
+	if (!authctxt->valid || (authctxt->pw->pw_uid == ROOT_UID &&
 	    options.permit_root_login != PERMIT_YES))
 		sshpam_password = badpw;
 
diff -ruN openssh-5.3p1.orig/auth-passwd.c openssh-5.3p1/auth-passwd.c
--- openssh-5.3p1.orig/auth-passwd.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/auth-passwd.c	2009-10-07 17:19:32 +0200
@@ -53,6 +53,12 @@
 #include "hostfile.h"
 #include "auth.h"
 #include "auth-options.h"
+#include "misc.h"
+
+#ifdef __INTERIX
+# include <interix/security.h>
+extern char* InterixPwdToken;
+#endif
 
 extern Buffer loginmsg;
 extern ServerOptions options;
@@ -87,7 +93,8 @@
 #endif
 
 #ifndef HAVE_CYGWIN
-	if (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)
+	/* hehe, the interix change would make this work on cygwin too :) */
+	if (pw->pw_uid == ROOT_UID && options.permit_root_login != PERMIT_YES)
 		ok = 0;
 #endif
 	if (*password == '\0' && options.permit_empty_passwd == 0)
@@ -111,6 +118,14 @@
 		return ok;
 	}
 #endif
+#ifdef __INTERIX
+	if(setuser(authctxt->user, password, SU_CHECK) == 0) {
+		InterixPwdToken = xstrdup(password);
+		return ok;
+	} else {
+		return 0;
+	}
+#endif
 #ifdef USE_PAM
 	if (options.use_pam)
 		return (sshpam_auth_passwd(authctxt, password) && ok);
diff -ruN openssh-5.3p1.orig/auth-rhosts.c openssh-5.3p1/auth-rhosts.c
--- openssh-5.3p1.orig/auth-rhosts.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/auth-rhosts.c	2009-10-07 17:19:32 +0200
@@ -230,7 +230,7 @@
 		return 0;
 
 	/* If not logging in as superuser, try /etc/hosts.equiv and shosts.equiv. */
-	if (pw->pw_uid != 0) {
+	if (pw->pw_uid != ROOT_UID) {
 		if (check_rhosts_file(_PATH_RHOSTS_EQUIV, hostname, ipaddr,
 		    client_user, pw->pw_name)) {
 			auth_debug_add("Accepted for %.100s [%.100s] by /etc/hosts.equiv.",
@@ -256,7 +256,7 @@
 		return 0;
 	}
 	if (options.strict_modes &&
-	    ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
+	    ((st.st_uid != ROOT_UID && st.st_uid != pw->pw_uid) ||
 	    (st.st_mode & 022) != 0)) {
 		logit("Rhosts authentication refused for %.100s: "
 		    "bad ownership or modes for home directory.", pw->pw_name);
@@ -283,7 +283,7 @@
 		 * allowing access to their account by anyone.
 		 */
 		if (options.strict_modes &&
-		    ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
+		    ((st.st_uid != ROOT_UID && st.st_uid != pw->pw_uid) ||
 		    (st.st_mode & 022) != 0)) {
 			logit("Rhosts authentication refused for %.100s: bad modes for %.200s",
 			    pw->pw_name, buf);
diff -ruN openssh-5.3p1.orig/auth-sia.c openssh-5.3p1/auth-sia.c
--- openssh-5.3p1.orig/auth-sia.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/auth-sia.c	2009-10-07 17:19:32 +0200
@@ -107,7 +107,7 @@
 
 	sia_ses_release(&ent);
 
-	setuid(0);
+	setuid(ROOT_UID);
 	permanently_set_uid(pw);
 }
 
diff -ruN openssh-5.3p1.orig/auth.c openssh-5.3p1/auth.c
--- openssh-5.3p1.orig/auth.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/auth.c	2009-10-07 17:19:32 +0200
@@ -378,7 +378,7 @@
 		user_hostfile = tilde_expand_filename(userfile, pw->pw_uid);
 		if (options.strict_modes &&
 		    (stat(user_hostfile, &st) == 0) &&
-		    ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
+		    ((st.st_uid != ROOT_UID && st.st_uid != pw->pw_uid) ||
 		    (st.st_mode & 022) != 0)) {
 			logit("Authentication refused for %.100s: "
 			    "bad owner or modes for %.200s",
@@ -431,7 +431,7 @@
 
 	/* check the open file to avoid races */
 	if (fstat(fileno(f), &st) < 0 ||
-	    (st.st_uid != 0 && st.st_uid != uid) ||
+	    (st.st_uid != ROOT_UID && st.st_uid != uid) ||
 	    (st.st_mode & 022) != 0) {
 		snprintf(err, errlen, "bad ownership or modes for file %s",
 		    buf);
@@ -448,7 +448,7 @@
 
 		debug3("secure_filename: checking '%s'", buf);
 		if (stat(buf, &st) < 0 ||
-		    (st.st_uid != 0 && st.st_uid != uid) ||
+		    (st.st_uid != ROOT_UID && st.st_uid != uid) ||
 		    (st.st_mode & 022) != 0) {
 			snprintf(err, errlen,
 			    "bad ownership or modes for directory %s", buf);
@@ -526,6 +526,26 @@
 	    get_canonical_hostname(options.use_dns), get_remote_ipaddr());
 
 	pw = getpwnam(user);
+
+#ifdef __INTERIX
+	/* on windows, is there is no such user in the principal domain
+	 * (which is checked by default), we also have a look at the
+	 * local accounts by prefixing the username with the hostname
+	 */
+	if (pw == NULL) {
+		char tmp[MAXHOSTNAMELEN];
+		if(gethostname(tmp, MAXHOSTNAMELEN) == 0) {
+			strcat(tmp, "+");
+			strcat(tmp, user);
+
+			pw = getpwnam(tmp);
+
+			if(pw)
+				debug2("found local %s as fallback for principal domain", tmp);
+		}
+	}
+#endif
+
 	if (pw == NULL) {
 		logit("Invalid user %.100s from %.100s",
 		    user, get_remote_ipaddr());
diff -ruN openssh-5.3p1.orig/auth1.c openssh-5.3p1/auth1.c
--- openssh-5.3p1.orig/auth1.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/auth1.c	2009-10-07 17:19:32 +0200
@@ -40,6 +40,7 @@
 #endif
 #include "monitor_wrap.h"
 #include "buffer.h"
+#include "misc.h"
 
 /* import */
 extern ServerOptions options;
@@ -320,7 +321,7 @@
 
 #ifndef HAVE_CYGWIN
 		/* Special handling for root */
-		if (authenticated && authctxt->pw->pw_uid == 0 &&
+		if (authenticated && authctxt->pw->pw_uid == ROOT_UID &&
 		    !auth_root_allowed(meth->name)) {
  			authenticated = 0;
 # ifdef SSH_AUDIT_EVENTS
@@ -419,7 +420,7 @@
 	 * the server.
 	 */
 #ifndef HAVE_CYGWIN
-	if (!use_privsep && getuid() != 0 && authctxt->pw &&
+	if (!use_privsep && getuid() != ROOT_UID && authctxt->pw &&
 	    authctxt->pw->pw_uid != getuid())
 		packet_disconnect("Cannot change user when server not running as root.");
 #endif
diff -ruN openssh-5.3p1.orig/auth2.c openssh-5.3p1/auth2.c
--- openssh-5.3p1.orig/auth2.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/auth2.c	2009-10-07 17:19:32 +0200
@@ -46,6 +46,7 @@
 #include "key.h"
 #include "hostfile.h"
 #include "auth.h"
+#include "misc.h"
 #include "dispatch.h"
 #include "pathnames.h"
 #include "buffer.h"
@@ -298,7 +299,7 @@
 		    authctxt->user);
 
 	/* Special handling for root */
-	if (authenticated && authctxt->pw->pw_uid == 0 &&
+	if (authenticated && authctxt->pw->pw_uid == ROOT_UID &&
 	    !auth_root_allowed(method)) {
 		authenticated = 0;
 #ifdef SSH_AUDIT_EVENTS
diff -ruN openssh-5.3p1.orig/configure.ac openssh-5.3p1/configure.ac
--- openssh-5.3p1.orig/configure.ac	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/configure.ac	2009-10-07 17:19:32 +0200
@@ -448,6 +448,25 @@
 		file descriptor passing])
 	AC_DEFINE(SSH_IOBUFSZ, 65536, [Windows is sensitive to read buffer size])
 	;;
+*-*-interix*)
+	AC_DEFINE(MISSING_HOWMANY, 1, [howmany macro is missing])
+	AC_DEFINE(USE_PIPES, 1, [Use PIPES instead of a socketpair()])
+	AC_DEFINE(DISABLE_LOGIN, 1,
+		[Define if you don't want to use your system's login() call])
+	AC_DEFINE(DISABLE_SHADOW, 1,
+	    [Define if you want to disable shadow passwords])
+	AC_DEFINE(IP_TOS_IS_BROKEN, 1,
+	    [Define if your system choked on IP TOS setting])
+	AC_DEFINE(NO_IPPORT_RESERVED_CONCEPT, 1,
+	    [Define if the concept of ports only accessible to
+		superusers isn't known])
+	AC_DEFINE(DISABLE_FD_PASSING, 1,
+		[Define if your platform needs to skip post auth
+		file descriptor passing])
+	AC_DEFINE(LOGIN_NO_ENDOPT, 1,
+	    [Define if your login program cannot handle end of options ("--")])
+	SSHDLIBS="$SSHDLIBS -lcrypt"
+	;;
 *-*-dgux*)
 	AC_DEFINE(IP_TOS_IS_BROKEN, 1,
 		[Define if your system choked on IP TOS setting])
diff -ruN openssh-5.3p1.orig/defines.h openssh-5.3p1/defines.h
--- openssh-5.3p1.orig/defines.h	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/defines.h	2009-10-07 17:19:32 +0200
@@ -732,7 +732,11 @@
 #endif
 
 #ifndef IOV_MAX
-# if defined(_XOPEN_IOV_MAX)
+# if defined(__INTERIX)
+   // Interix: has _XOPEN_IOV_MAX = INT_MAX which breaks
+   // the compilation, since an iovec array of INT_MAX is too large
+#  define	IOV_MAX		_SC_IOV_MAX
+# elif defined(_XOPEN_IOV_MAX)
 #  define	IOV_MAX		_XOPEN_IOV_MAX
 # elif defined(DEF_IOV_MAX)
 #  define	IOV_MAX		DEF_IOV_MAX
diff -ruN openssh-5.3p1.orig/hostfile.c openssh-5.3p1/hostfile.c
--- openssh-5.3p1.orig/hostfile.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/hostfile.c	2009-10-07 17:19:32 +0200
@@ -45,7 +45,9 @@
 #include <openssl/hmac.h>
 #include <openssl/sha.h>
 
-#include <resolv.h>
+#ifndef __INTERIX
+# include <resolv.h>
+#endif
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
diff -ruN openssh-5.3p1.orig/loginrec.c openssh-5.3p1/loginrec.c
--- openssh-5.3p1.orig/loginrec.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/loginrec.c	2009-10-07 17:19:32 +0200
@@ -175,6 +175,7 @@
 #include "canohost.h"
 #include "auth.h"
 #include "buffer.h"
+#include "misc.h"
 
 #ifdef HAVE_UTIL_H
 # include <util.h>
@@ -432,7 +433,7 @@
 login_write(struct logininfo *li)
 {
 #ifndef HAVE_CYGWIN
-	if (geteuid() != 0) {
+	if (geteuid() != ROOT_UID) {
 		logit("Attempt to write login records by non-root user (aborting)");
 		return (1);
 	}
@@ -1629,7 +1630,7 @@
 	time_t t;
 	struct stat fst;
 
-	if (geteuid() != 0)
+	if (geteuid() != ROOT_UID)
 		return;
 	if ((fd = open(_PATH_BTMP, O_WRONLY | O_APPEND)) < 0) {
 		debug("Unable to open the btmp file %s: %s", _PATH_BTMP,
@@ -1641,7 +1642,7 @@
 		    strerror(errno));
 		goto out;
 	}
-	if((fst.st_mode & (S_IRWXG | S_IRWXO)) || (fst.st_uid != 0)){
+	if((fst.st_mode & (S_IRWXG | S_IRWXO)) || (fst.st_uid != ROOT_UID)){
 		logit("Excess permission or bad ownership on file %s",
 		    _PATH_BTMP);
 		goto out;
diff -ruN openssh-5.3p1.orig/logintest.c openssh-5.3p1/logintest.c
--- openssh-5.3p1.orig/logintest.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/logintest.c	2009-10-07 17:19:32 +0200
@@ -125,7 +125,7 @@
 	if (be_verbose)
 		dump_logininfo(li1, "li1");
 
-	if ((int)geteuid() != 0) {
+	if ((int)geteuid() != ROOT_UID) {
 		printf("NOT RUNNING LOGIN TESTS - you are not root!\n");
 		return 1;
 	}
diff -ruN openssh-5.3p1.orig/misc.h openssh-5.3p1/misc.h
--- openssh-5.3p1.orig/misc.h	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/misc.h	2009-10-07 17:19:32 +0200
@@ -15,6 +15,18 @@
 #ifndef _MISC_H
 #define _MISC_H
 
+/* This one is required for propper interix support, since there the "root" user
+ * is Administrator (or maybe something else). In any case the uid of that user
+ * is 197108 (i guess that this has some meaning when doing strange int -> char
+ * transformations...) */
+#ifdef __INTERIX
+# define ROOT_UID 197108
+# define ROOT_GID 131616
+#else
+# define ROOT_UID 0
+# define ROOT_GID 0
+#endif
+
 /* misc.c */
 
 char	*chop(char *);
diff -ruN openssh-5.3p1.orig/monitor.c openssh-5.3p1/monitor.c
--- openssh-5.3p1.orig/monitor.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/monitor.c	2009-10-07 17:19:32 +0200
@@ -371,7 +371,7 @@
 			if (!(ent->flags & MON_AUTHDECIDE))
 				fatal("%s: unexpected authentication from %d",
 				    __func__, ent->type);
-			if (authctxt->pw->pw_uid == 0 &&
+			if (authctxt->pw->pw_uid == ROOT_UID &&
 			    !auth_root_allowed(auth_method))
 				authenticated = 0;
 #ifdef USE_PAM
diff -ruN openssh-5.3p1.orig/mux.c openssh-5.3p1/mux.c
--- openssh-5.3p1.orig/mux.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/mux.c	2009-10-07 17:19:32 +0200
@@ -246,7 +246,7 @@
 		close(client_fd);
 		return 0;
 	}
-	if ((euid != 0) && (getuid() != euid)) {
+	if ((euid != ROOT_UID) && (getuid() != euid)) {
 		error("control mode uid mismatch: peer euid %u != uid %u",
 		    (u_int) euid, (u_int) getuid());
 		close(client_fd);
diff -ruN openssh-5.3p1.orig/openbsd-compat/bsd-misc.h openssh-5.3p1/openbsd-compat/bsd-misc.h
--- openssh-5.3p1.orig/openbsd-compat/bsd-misc.h	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/openbsd-compat/bsd-misc.h	2009-10-07 17:19:32 +0200
@@ -68,12 +68,14 @@
 #endif /* HAVE_TRUNCATE */
 
 #if !defined(HAVE_NANOSLEEP) && !defined(HAVE_NSLEEP)
+#ifndef __INTERIX
 #ifndef HAVE_STRUCT_TIMESPEC
 struct timespec {
 	time_t	tv_sec;
 	long	tv_nsec;
 };
 #endif
+#endif
 int nanosleep(const struct timespec *, struct timespec *);
 #endif
 
diff -ruN openssh-5.3p1.orig/openbsd-compat/getrrsetbyname.c openssh-5.3p1/openbsd-compat/getrrsetbyname.c
--- openssh-5.3p1.orig/openbsd-compat/getrrsetbyname.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/openbsd-compat/getrrsetbyname.c	2009-10-07 17:19:32 +0200
@@ -61,6 +61,10 @@
 extern int h_errno;
 #endif
 
+/* on interix, all this stuff won't work that easy
+ * so we skip it for now. */
+#if !defined(__INTERIX)
+
 /* We don't need multithread support here */
 #ifdef _THREAD_PRIVATE
 # undef _THREAD_PRIVATE
@@ -182,11 +186,16 @@
 
 static int count_dns_rr(struct dns_rr *, u_int16_t, u_int16_t);
 
+#endif /* __INTERIX */
+
 int
 getrrsetbyname(const char *hostname, unsigned int rdclass,
     unsigned int rdtype, unsigned int flags,
     struct rrsetinfo **res)
 {
+#if defined(__INTERIX)
+	return (ERRSET_FAIL);
+#else
 	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
 	int result;
 	struct rrsetinfo *rrset = NULL;
@@ -343,6 +352,7 @@
 	if (response != NULL)
 		free_dns_response(response);
 	return (result);
+#endif
 }
 
 void
@@ -376,6 +386,8 @@
 	free(rrset);
 }
 
+#if !defined(__INTERIX)
+
 /*
  * DNS response parsing routines
  */
@@ -607,4 +619,6 @@
 	return (n);
 }
 
+#endif /* __INTERIX */
+
 #endif /* !defined(HAVE_GETRRSETBYNAME) */
diff -ruN openssh-5.3p1.orig/openbsd-compat/getrrsetbyname.h openssh-5.3p1/openbsd-compat/getrrsetbyname.h
--- openssh-5.3p1.orig/openbsd-compat/getrrsetbyname.h	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/openbsd-compat/getrrsetbyname.h	2009-10-07 17:19:32 +0200
@@ -54,9 +54,11 @@
 
 #include <sys/types.h>
 #include <netinet/in.h>
-#include <arpa/nameser.h>
+#ifndef __INTERIX
+# include <arpa/nameser.h>
+# include <resolv.h>
+#endif
 #include <netdb.h>
-#include <resolv.h>
 
 #ifndef HFIXEDSZ
 #define HFIXEDSZ 12
diff -ruN openssh-5.3p1.orig/openbsd-compat/inet_ntop.c openssh-5.3p1/openbsd-compat/inet_ntop.c
--- openssh-5.3p1.orig/openbsd-compat/inet_ntop.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/openbsd-compat/inet_ntop.c	2009-10-07 17:19:32 +0200
@@ -27,7 +27,9 @@
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
-#include <arpa/nameser.h>
+#ifndef __INTERIX
+# include <arpa/nameser.h>
+#endif
 #include <string.h>
 #include <errno.h>
 #include <stdio.h>
diff -ruN openssh-5.3p1.orig/openbsd-compat/port-aix.c openssh-5.3p1/openbsd-compat/port-aix.c
--- openssh-5.3p1.orig/openbsd-compat/port-aix.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/openbsd-compat/port-aix.c	2009-10-07 17:19:32 +0200
@@ -33,6 +33,7 @@
 #include "auth.h"
 #include "ssh.h"
 #include "log.h"
+#include "misc.h"
 
 #ifdef _AIX
 
@@ -245,7 +246,7 @@
 	 * logins via ssh) or if running as non-root user (since
 	 * loginrestrictions will always fail due to insufficient privilege).
 	 */
-	if (pw->pw_uid == 0 || geteuid() != 0) {
+	if (pw->pw_uid == ROOT_UID || geteuid() != ROOT_UID) {
 		debug3("%s: not checking", __func__);
 		return 1;
 	}
@@ -309,7 +310,7 @@
 void
 record_failed_login(const char *user, const char *hostname, const char *ttyname)
 {
-	if (geteuid() != 0)
+	if (geteuid() != ROOT_UID)
 		return;
 
 	aix_setauthdb(user);
diff -ruN openssh-5.3p1.orig/readconf.c openssh-5.3p1/readconf.c
--- openssh-5.3p1.orig/readconf.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/readconf.c	2009-10-07 17:19:32 +0200
@@ -253,7 +253,7 @@
 	Forward *fwd;
 #ifndef NO_IPPORT_RESERVED_CONCEPT
 	extern uid_t original_real_uid;
-	if (newfwd->listen_port < IPPORT_RESERVED && original_real_uid != 0)
+	if (newfwd->listen_port < IPPORT_RESERVED && original_real_uid != ROOT_UID)
 		fatal("Privileged ports can only be forwarded by root.");
 #endif
 	if (options->num_local_forwards >= SSH_MAX_FORWARDS_PER_DIRECTION)
@@ -972,7 +972,7 @@
 
 		if (fstat(fileno(f), &sb) == -1)
 			fatal("fstat %s: %s", filename, strerror(errno));
-		if (((sb.st_uid != 0 && sb.st_uid != getuid()) ||
+		if (((sb.st_uid != ROOT_UID && sb.st_uid != getuid()) ||
 		    (sb.st_mode & 022) != 0))
 			fatal("Bad owner or permissions on %s", filename);
 	}
diff -ruN openssh-5.3p1.orig/serverloop.c openssh-5.3p1/serverloop.c
--- openssh-5.3p1.orig/serverloop.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/serverloop.c	2009-10-07 17:20:08 +0200
@@ -1125,7 +1125,7 @@
 		    (!want_reply && listen_port == 0)
 #ifndef NO_IPPORT_RESERVED_CONCEPT
 		    || (listen_port != 0 && listen_port < IPPORT_RESERVED &&
-                    pw->pw_uid != 0)
+                    pw->pw_uid != ROOT_UID)
 #endif
 		    ) {
 			success = 0;
diff -ruN openssh-5.3p1.orig/session.c openssh-5.3p1/session.c
--- openssh-5.3p1.orig/session.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/session.c	2009-10-07 17:20:20 +0200
@@ -91,6 +91,27 @@
 #include "monitor_wrap.h"
 #include "sftp.h"
 
+#ifdef __INTERIX
+# include <interix/env.h>
+# include <interix/security.h>
+char* InterixPwdToken = NULL;
+
+#define INTERIX_PWD_WARNING \
+		fprintf(stderr,"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n" \
+					   "@ WARNING: Due to limitations in the POSIX Subsystem and Win32  @\n" \
+					   "@     a Password is required to acquire a full authentication.  @\n" \
+					   "@     Without such an authentication token, certain things will @\n" \
+					   "@     only be available in a very limited way (Visual Studio's  @\n" \
+					   "@     link.exe can only link without debug information, network @\n" \
+					   "@     shares that require user authentication don't fully work, @\n" \
+					   "@     etc.). However if you don't require those things to work, @\n" \
+					   "@     you may be just fine without password (public-key, etc.). @\n" \
+					   "@ To obtain a full authentication you need to use password      @\n" \
+					   "@ authentication at the moment. To do so, remove your public    @\n" \
+					   "@ key from your ~/.ssh/authorized_keys[2] file(s).              @\n" \
+					   "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
+#endif
+
 #if defined(KRB5) && defined(USE_AFS)
 #include <kafs.h>
 #endif
@@ -380,7 +401,7 @@
 				break;
 			}
 			debug("Received TCP/IP port forwarding request.");
-			if (channel_input_port_forward_request(s->pw->pw_uid == 0,
+			if (channel_input_port_forward_request(s->pw->pw_uid == ROOT_UID,
 			    options.gateway_ports) < 0) {
 				debug("Port forwarding failed.");
 				break;
@@ -1066,7 +1087,7 @@
 	if (tmpenv == NULL)
 		return;
 
-	if (uid == 0)
+	if (uid == ROOT_UID)
 		var = child_get_env(tmpenv, "SUPATH");
 	else
 		var = child_get_env(tmpenv, "PATH");
@@ -1137,6 +1158,17 @@
 	}
 #endif
 
+#ifdef __INTERIX
+	{
+		/* new stuff: create a full windows login environment */
+		struct passwd* fullpw = getpwuid_ex(pw->pw_uid, PW_FULLNAME);
+		env_t* w_env = env_login(fullpw);
+		
+		copy_environment(env_array(w_env), &env, &envsize);
+		env_free(w_env);
+	}
+#endif
+
 #ifdef GSSAPI
 	/* Allow any GSSAPI methods that we've used to alter
 	 * the childs environment as they see fit
@@ -1175,7 +1207,7 @@
 #  endif /* HAVE_ETC_DEFAULT_LOGIN */
 		if (path == NULL || *path == '\0') {
 			child_set_env(&env, &envsize, "PATH",
-			    s->pw->pw_uid == 0 ?
+			    s->pw->pw_uid == ROOT_UID ?
 				SUPERUSER_PATH : _PATH_STDPATH);
 		}
 # endif /* HAVE_CYGWIN */
@@ -1377,11 +1409,11 @@
 	char buf[1024];
 
 #ifdef HAVE_LOGIN_CAP
-	if (!login_getcapbool(lc, "ignorenologin", 0) && pw->pw_uid)
+	if (!login_getcapbool(lc, "ignorenologin", 0) && pw->pw_uid != ROOT_UID)
 		f = fopen(login_getcapstr(lc, "nologin", _PATH_NOLOGIN,
 		    _PATH_NOLOGIN), "r");
 #else
-	if (pw->pw_uid)
+	if (pw->pw_uid != ROOT_UID)
 		f = fopen(_PATH_NOLOGIN, "r");
 #endif
 	if (f) {
@@ -1430,7 +1462,7 @@
 		if (stat(component, &st) != 0)
 			fatal("%s: stat(\"%s\"): %s", __func__,
 			    component, strerror(errno));
-		if (st.st_uid != 0 || (st.st_mode & 022) != 0)
+		if (st.st_uid != ROOT_UID || (st.st_mode & 022) != 0)
 			fatal("bad ownership or modes for chroot "
 			    "directory %s\"%s\"", 
 			    cp == NULL ? "" : "component ", component);
@@ -1463,7 +1495,7 @@
 #endif
 
 #ifndef HAVE_CYGWIN
-	if (getuid() == 0 || geteuid() == 0)
+	if (getuid() == ROOT_UID || geteuid() == ROOT_UID)
 #endif /* HAVE_CYGWIN */
 	{
 #ifdef HAVE_LOGIN_CAP
@@ -1493,11 +1525,13 @@
 			perror("setgid");
 			exit(1);
 		}
+#ifndef __INTERIX
 		/* Initialize the group list. */
 		if (initgroups(pw->pw_name, pw->pw_gid) < 0) {
 			perror("initgroups");
 			exit(1);
 		}
+#endif
 		endgrent();
 # ifdef USE_PAM
 		/*
@@ -1543,8 +1577,29 @@
 			exit(1);
 		}
 #else
+#ifdef __INTERIX
+		/* on interix, to get a full env, we _need_ the plain text
+		 * password during this! */
+		if(InterixPwdToken) {
+			debug2("re-setting user password");
+			strcpy(pw->pw_passwd, InterixPwdToken);
+		} else {
+			INTERIX_PWD_WARNING
+		}
+#endif
 		/* Permanently switch to the desired uid. */
 		permanently_set_uid(pw);
+
+#ifdef __INTERIX
+		/* after authentication, wipe out the memorized password
+		 * for increased security (tm) */
+		if(InterixPwdToken) {
+			memset(InterixPwdToken, 0, strlen(InterixPwdToken));
+			memset(pw->pw_passwd, 0, strlen(pw->pw_passwd));
+			strcpy(pw->pw_passwd, "*");
+			debug2("wiped password from memory");
+		}
+#endif
 #endif
 	}
 
@@ -1582,6 +1637,13 @@
 launch_login(struct passwd *pw, const char *hostname)
 {
 	/* Launch login(1). */
+	#ifdef __INTERIX
+	/* -f only works if the user is already autheticated as the requested user */
+	if (!InterixPwdToken)
+		INTERIX_PWD_WARNING
+	if (setuser(pw->pw_name, InterixPwdToken, SU_COMPLETE))
+		fatal("setuser %.100s: %.100s", pw->pw_name, strerror(errno));
+	#endif
 
 	execl(LOGIN_PROGRAM, "login", "-h", hostname,
 #ifdef xxxLOGIN_NEEDS_TERM
@@ -2322,7 +2384,7 @@
 		record_logout(s->pid, s->tty, s->pw->pw_name);
 
 	/* Release the pseudo-tty. */
-	if (getuid() == 0)
+	if (getuid() == ROOT_UID)
 		pty_release(s->tty);
 
 	/*
diff -ruN openssh-5.3p1.orig/ssh-agent.c openssh-5.3p1/ssh-agent.c
--- openssh-5.3p1.orig/ssh-agent.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/ssh-agent.c	2009-10-07 17:19:32 +0200
@@ -943,7 +943,7 @@
 					close(sock);
 					break;
 				}
-				if ((euid != 0) && (getuid() != euid)) {
+				if ((euid != ROOT_UID) && (getuid() != euid)) {
 					error("uid mismatch: "
 					    "peer euid %u != uid %u",
 					    (u_int) euid, (u_int) getuid());
diff -ruN openssh-5.3p1.orig/ssh.c openssh-5.3p1/ssh.c
--- openssh-5.3p1.orig/ssh.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/ssh.c	2009-10-07 17:19:32 +0200
@@ -708,7 +708,7 @@
 #ifdef HAVE_CYGWIN
 	    options.use_privileged_port,
 #else
-	    original_effective_uid == 0 && options.use_privileged_port,
+	    original_effective_uid == ROOT_UID && options.use_privileged_port,
 #endif
 	    options.proxy_command) != 0)
 		exit(255);
@@ -760,7 +760,7 @@
 	 * user's home directory if it happens to be on a NFS volume where
 	 * root is mapped to nobody.
 	 */
-	if (original_effective_uid == 0) {
+	if (original_effective_uid == ROOT_UID) {
 		PRIV_START;
 		permanently_set_uid(pw);
 	}
diff -ruN openssh-5.3p1.orig/sshd.c openssh-5.3p1/sshd.c
--- openssh-5.3p1.orig/sshd.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/sshd.c	2009-10-07 17:20:24 +0200
@@ -137,6 +137,10 @@
 #define REEXEC_CONFIG_PASS_FD		(STDERR_FILENO + 3)
 #define REEXEC_MIN_FREE_FD		(STDERR_FILENO + 4)
 
+#ifdef __INTERIX
+# include <interix/security.h>
+#endif
+
 extern char *__progname;
 
 /* Server configuration options. */
@@ -235,7 +239,11 @@
 int startup_pipe;		/* in child */
 
 /* variables used for privilege separation */
+#ifdef __INTERIX
+int use_privsep = 0;
+#else
 int use_privsep = -1;
+#endif
 struct monitor *pmonitor = NULL;
 
 /* global authentication context */
@@ -606,8 +614,10 @@
 	do_setusercontext(privsep_pw);
 #else
 	gidset[0] = privsep_pw->pw_gid;
+#ifndef __INTERIX
 	if (setgroups(1, gidset) < 0)
 		fatal("setgroups: %.100s", strerror(errno));
+#endif
 	permanently_set_uid(privsep_pw);
 #endif
 }
@@ -648,7 +658,7 @@
 		close(pmonitor->m_sendfd);
 
 		/* Demote the child */
-		if (getuid() == 0 || geteuid() == 0)
+		if (getuid() == ROOT_UID || geteuid() == ROOT_UID)
 			privsep_preauth_child();
 		setproctitle("%s", "[net]");
 	}
@@ -663,7 +673,7 @@
 #ifdef DISABLE_FD_PASSING
 	if (1) {
 #else
-	if (authctxt->pw->pw_uid == 0 || options.use_login) {
+	if (authctxt->pw->pw_uid == ROOT_UID || options.use_login) {
 #endif
 		/* File descriptor passing is broken or root login */
 		use_privsep = 0;
@@ -1273,8 +1283,10 @@
 	av = saved_argv;
 #endif
 
-	if (geteuid() == 0 && setgroups(0, NULL) == -1)
+#ifndef __INTERIX
+	if (geteuid() == ROOT_UID && setgroups(0, NULL) == -1)
 		debug("setgroups(): %.200s", strerror(errno));
+#endif
 
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
 	sanitise_stdfd();
@@ -1486,6 +1498,31 @@
 
 	debug("sshd version %.100s", SSH_RELEASE);
 
+#ifdef __INTERIX
+	/* on interix >= 6, there is a problem is sshd is started from init:
+	 * even though the process runs as "Administrator", it seems that
+	 * the authentication token is pretty much stripped down, so it is
+	 * not possible for the process to impersonate another user.
+	 * impersonating ourself works around the problem by creating a full
+	 * authetication token for the current user (Administrator...), which
+	 * then is allowed to set uid/gid of any other user as normal. */
+	{
+		struct passwd* _admin = getpwuid(getuid());
+
+		if(!_admin) {
+			fprintf(stderr, "Cannot retrieve user information for current user!\n");
+			exit(2);
+		}
+
+		debug3("impersonating %s to upgrade authentication token\n", _admin->pw_name);
+
+		if(setuser(_admin->pw_name, NULL, SU_COMPLETE) != 0) {
+			fprintf(stderr, "Cannot obtain full authentication for current user: %s\n", strerror(errno));
+			exit(2);
+		}
+	}
+#endif
+
 	/* Store privilege separation user for later use if required. */
 	if ((privsep_pw = getpwnam(SSH_PRIVSEP_USER)) == NULL) {
 		if (use_privsep || options.kerberos_authentication)
@@ -1578,7 +1615,7 @@
 		    (st.st_uid != getuid () ||
 		    (st.st_mode & (S_IWGRP|S_IWOTH)) != 0))
 #else
-		if (st.st_uid != 0 || (st.st_mode & (S_IWGRP|S_IWOTH)) != 0)
+		if (st.st_uid != ROOT_UID || (st.st_mode & (S_IWGRP|S_IWOTH)) != 0)
 #endif
 			fatal("%s must be owned by root and not group or "
 			    "world-writable.", _PATH_PRIVSEP_CHROOT_DIR);
@@ -1602,8 +1639,10 @@
 	 * to create a file, and we can't control the code in every
 	 * module which might be used).
 	 */
+#ifndef __INTERIX
 	if (setgroups(0, NULL) < 0)
 		debug("setgroups() failed: %.200s", strerror(errno));
+#endif
 
 	if (rexec_flag) {
 		rexec_argv = xcalloc(rexec_argc + 2, sizeof(char *));
diff -ruN openssh-5.3p1.orig/sshpty.c openssh-5.3p1/sshpty.c
--- openssh-5.3p1.orig/sshpty.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/sshpty.c	2009-10-07 17:19:32 +0200
@@ -86,7 +86,7 @@
 pty_release(const char *tty)
 {
 #ifndef __APPLE_PRIVPTY__
-	if (chown(tty, (uid_t) 0, (gid_t) 0) < 0)
+	if (chown(tty, (uid_t) ROOT_UID, (gid_t) ROOT_GID) < 0)
 		error("chown %.100s 0 0 failed: %.100s", tty, strerror(errno));
 	if (chmod(tty, (mode_t) 0666) < 0)
 		error("chmod %.100s 0666 failed: %.100s", tty, strerror(errno));
@@ -233,7 +233,7 @@
 	if (st.st_uid != pw->pw_uid || st.st_gid != gid) {
 		if (chown(tty, pw->pw_uid, gid) < 0) {
 			if (errno == EROFS &&
-			    (st.st_uid == pw->pw_uid || st.st_uid == 0))
+			    (st.st_uid == pw->pw_uid || st.st_uid == ROOT_UID))
 				debug("chown(%.100s, %u, %u) failed: %.100s",
 				    tty, (u_int)pw->pw_uid, (u_int)gid,
 				    strerror(errno));
diff -ruN openssh-5.3p1.orig/uidswap.c openssh-5.3p1/uidswap.c
--- openssh-5.3p1.orig/uidswap.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/uidswap.c	2009-10-07 17:20:20 +0200
@@ -14,6 +14,10 @@
 
 #include "includes.h"
 
+#ifdef __INTERIX
+# include <interix/security.h>
+#endif
+
 #include <sys/param.h>
 #include <errno.h>
 #include <pwd.h>
@@ -26,6 +30,7 @@
 #include "log.h"
 #include "uidswap.h"
 #include "xmalloc.h"
+#include "misc.h"
 
 /*
  * Note: all these functions must work in all of the following cases:
@@ -66,13 +71,13 @@
 	    (u_int)pw->pw_uid, (u_int)pw->pw_gid,
 	    (u_int)saved_euid, (u_int)saved_egid);
 #ifndef HAVE_CYGWIN
-	if (saved_euid != 0) {
+	if (saved_euid != ROOT_UID) {
 		privileged = 0;
 		return;
 	}
 #endif
 #else
-	if (geteuid() != 0) {
+	if (geteuid() != ROOT_UID) {
 		privileged = 0;
 		return;
 	}
@@ -81,6 +86,7 @@
 	privileged = 1;
 	temporarily_use_uid_effective = 1;
 
+#ifndef __INTERIX
 	saved_egroupslen = getgroups(0, NULL);
 	if (saved_egroupslen < 0)
 		fatal("getgroups: %.100s", strerror(errno));
@@ -116,6 +122,7 @@
 	/* Set the effective uid to the given (unprivileged) uid. */
 	if (setgroups(user_groupslen, user_groups) < 0)
 		fatal("setgroups: %.100s", strerror(errno));
+#endif
 #ifndef SAVED_IDS_WORK_WITH_SETEUID
 	/* Propagate the privileged gid to all of our gids. */
 	if (setgid(getegid()) < 0)
@@ -153,7 +160,7 @@
 		fatal("setuid %u: %.100s", (u_int)uid, strerror(errno));
 #endif
 
-#ifndef HAVE_CYGWIN
+#if !defined(HAVE_CYGWIN) && !defined(__INTERIX)
 	/* Try restoration of UID if changed (test clearing of saved uid) */
 	if (old_uid != uid &&
 	    (setuid(old_uid) != -1 || seteuid(old_uid) != -1))
@@ -198,8 +205,10 @@
 	setgid(getgid());
 #endif /* SAVED_IDS_WORK_WITH_SETEUID */
 
+#ifndef __INTERIX
 	if (setgroups(saved_egroupslen, saved_egroups) < 0)
 		fatal("setgroups: %.100s", strerror(errno));
+#endif
 	temporarily_use_uid_effective = 0;
 }
 
@@ -220,6 +229,20 @@
 	debug("permanently_set_uid: %u/%u", (u_int)pw->pw_uid,
 	    (u_int)pw->pw_gid);
 
+#ifdef __INTERIX
+	if (0) {
+		fprintf(stderr, "WARNING: Your password will expire soon. This will make remote\n"
+						"logins via ssh impossible without notice of the occured error!\n");
+	}
+
+	if (strcmp(pw->pw_passwd, "*") == 0) {
+		if (setuser(pw->pw_name, NULL, SU_COMPLETE))
+			fatal("setuser %.100s: %.100s", pw->pw_name, strerror(errno));
+	} else {
+		if (setuser(pw->pw_name, pw->pw_passwd, SU_COMPLETE))
+			fatal("setuser %.100s: %.100s", pw->pw_name, strerror(errno));
+	}
+#else
 #if defined(HAVE_SETRESGID) && !defined(BROKEN_SETRESGID)
 	if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) < 0)
 		fatal("setresgid %u: %.100s", (u_int)pw->pw_gid, strerror(errno));
@@ -257,10 +280,11 @@
 	if (setuid(pw->pw_uid) < 0)
 		fatal("setuid %u: %.100s", (u_int)pw->pw_uid, strerror(errno));
 #endif
+#endif /* __INTERIX */
 
-#ifndef HAVE_CYGWIN
+#if !defined(HAVE_CYGWIN) && !defined(__INTERIX)
 	/* Try restoration of GID if changed (test clearing of saved gid) */
-	if (old_gid != pw->pw_gid && pw->pw_uid != 0 &&
+	if (old_gid != pw->pw_gid && pw->pw_uid != ROOT_UID &&
 	    (setgid(old_gid) != -1 || setegid(old_gid) != -1))
 		fatal("%s: was able to restore old [e]gid", __func__);
 #endif
@@ -272,7 +296,7 @@
 		    (u_int)pw->pw_gid);
 	}
 
-#ifndef HAVE_CYGWIN
+#if !defined(HAVE_CYGWIN) && !defined(__INTERIX)
 	/* Try restoration of UID if changed (test clearing of saved uid) */
 	if (old_uid != pw->pw_uid &&
 	    (setuid(old_uid) != -1 || seteuid(old_uid) != -1))
diff -ruN openssh-5.3p1.orig/uuencode.c openssh-5.3p1/uuencode.c
--- openssh-5.3p1.orig/uuencode.c	2009-10-07 17:18:14 +0200
+++ openssh-5.3p1/uuencode.c	2009-10-07 17:19:32 +0200
@@ -27,7 +27,9 @@
 
 #include <sys/types.h>
 #include <netinet/in.h>
-#include <resolv.h>
+#ifndef __INTERIX
+# include <resolv.h>
+#endif
 #include <stdio.h>
 
 #include "xmalloc.h"
